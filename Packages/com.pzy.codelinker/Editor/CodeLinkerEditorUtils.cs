using UnityEngine;
using System.Collections;
using System.Text;
using System;
using System.Collections.Generic;
using System.IO;
using UnityEditor;

namespace ElementSystem
{

    public static class CodeLinkerEditorUtils 
    {

        public static void GenerateCodeForTree(CodeLinkerObject tree)
        {

            var mainComponent = tree.GetComponent(tree.name);
            //var hotComponentCreator = tree.GetComponent<HotBehaviorCreator>();
            string superClassName = "";

            if(mainComponent != null)
            {
                superClassName = mainComponent.GetType().BaseType.Name;
            }
            //else if(hotComponentCreator != null)
            //{
            //    var hotClass = hotComponentCreator.ClassType;
            //    var bassClass = hotClass.BaseType.Name;
            //    superClassName = bassClass;
            //}
            else
            {
                superClassName = "MonoBehaviour";
            }

  
            var sb = new StringBuilder();
            // string className = "";
            // var parentDesigner = tree.transform.parent.GetComponentInParent<ElementDesigner>();
            // if (parentDesigner != null)
            // {
            //     className = parentDesigner.name + "_" + tree.name;
            // }
            // else
            // {
            //     className = tree.name;
            // }
            // className = className.Replace("$", "");
            var nowDate = DateTime.Now;
            var timeString = nowDate.ToString("yyyy/MM/dd HH:mm:ss");

            string className = tree.GetClassName();

            sb.AppendLine("using UnityEngine;");
            //sb.AppendLine("using ElementSystem;");
            sb.AppendLine("using UnityEngine.UI;");
            sb.AppendLine("using System;");
            sb.AppendLine("using DG.Tweening;");
            sb.AppendLine("using Spine.Unity;");
            sb.AppendLine("using Sirenix.OdinInspector;");
            sb.AppendLine("using TMPro;");
            sb.AppendLine();
            sb.AppendLine("// This file was auto generated by CodeLinker");
            sb.AppendLine($"// update time : " + timeString);
            sb.AppendLine("public partial class " + className + " : " + superClassName);
            sb.AppendLine("{");

            // 寻找所有$变量transform
            var transformToTreePathDic = new Dictionary<Transform, string>();
            FindMark(true, tree.transform, transformToTreePathDic, "");

            // 生成属性
            foreach (var kv in transformToTreePathDic)
            {
                var tranfrom = kv.Key;
                var path = kv.Value;
                var variableName = tranfrom.name;
                if(path == "")
                {
                    // 根结点不需要生成索引
                    continue;
                }
                variableName = variableName.Trim('$');
                variableName = variableName.Trim('@');
                variableName = variableName.Replace("$", "_");
                variableName = variableName.Replace("@", "_");
                variableName = variableName.Replace(" ", "_");
                variableName = variableName.Replace("+", "_");
                variableName = variableName.Replace("-", "_");
                variableName = variableName.Replace(".", "_");
                variableName = variableName.Replace("<", "_");
                variableName = variableName.Replace(">", "_");
                variableName = variableName.Replace("[", "_");
                variableName = variableName.Replace("]", "_");
                variableName = variableName.Trim('_');
                var propertyName = ToProertyFormat(variableName);
                var backfeildName = ToBackfeildFormat(variableName);
                // 决定type
                var typeName = DecideTypeName(tranfrom);

                sb.AppendLine("\tprivate " + typeName + " " + backfeildName + ";");
                sb.AppendLine("\tprotected " + typeName + " " + propertyName);
                sb.AppendLine("\t{");
                sb.AppendLine("\t\tget");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(" + backfeildName + " == null)");
                sb.AppendLine("\t\t\t{");
                sb.AppendLine("\t\t\t\tvar t = CodeLinkerUtil.FindByPath(transform, \"" + path + "\");");
                sb.AppendLine("\t\t\t\t" + backfeildName + " = t.gameObject.GetComponent<" + typeName + ">();");
                sb.AppendLine("\t\t\t}");
                sb.AppendLine("\t\t\treturn " + backfeildName + ";");
                sb.AppendLine("\t\t}");
                sb.AppendLine("\t}");
                sb.AppendLine();
            }

            // 结束部分类
            sb.AppendLine("}");
            // 代码
            var code = sb.ToString();
            // 写文件
            var filePath = ResolveCodeFilePath(className);
            File.WriteAllText(filePath, code);
            AssetDatabase.Refresh();
            Debug.Log("[CodeLinker] code generated at: " + filePath);
        }

        private static string DecideTypeName(Transform tranfrom)
        {
            //var hotCreator = tranfrom.GetComponent<HotBehaviorCreator>();
            //if(hotCreator != null)
            //{
            //    var type = hotCreator.ClassType;
            //    var name = type.Name;
            //    return name;
            //}

            var compponentSerachTypeList = new Type[]
            {
                    // typeof(Element),
                    // typeof(ElementScrollView),
                    // typeof(View),
                    // typeof(UIWidget),
                    // typeof(UIRect),
                    // typeof(UIWidgetContainer),
                    //typeof(ScrollViewHelper),
                    //typeof(UIPoolList),
                    typeof(ParticleSystem),
                    typeof(MonoBehaviour),
                    typeof(Component),
            };
            foreach (var type in compponentSerachTypeList)
            {
                var comList = tranfrom.GetComponents(type);
                if (comList.Length == 0)
                {
                    continue;
                }
                foreach (var com in comList)
                {
                    var thisTypeName = com.GetType().Name;
                    if (thisTypeName == "CodeLinkerObject")
                    {
                        continue;
                    }
                    if (thisTypeName == "Transform")
                    {
                        continue;
                    }
                    if(thisTypeName == "RectTransform")
                    {
                        continue;
                    }
                    return thisTypeName;
                }
            }

            if(tranfrom.GetComponent<RectTransform>() != null)
            {
                return "RectTransform";
            }
            else
            {
                return "Transform";
            }
        }

        private static void FindMark(bool isRoot, Transform t, Dictionary<Transform, string> dic, string parentPath)
        {
            if (t.name.Contains("/"))
            {
                throw new Exception("transform name can't contains '/'");
            }
            string path;
            if (isRoot)
            {
                path = "";
            }
            else
            {
                path = parentPath == "" ? t.name : parentPath + "/" + t.name;
            }
            bool rescure = true;
            if (t.name.StartsWith("$"))
            {
                dic[t] = path;
            }
            else if (t.name.StartsWith("@"))
            {
                dic[t] = path;
                rescure = false;
            }
            else if (t.name.StartsWith("."))
            {
                rescure = false;
            }

            if (!isRoot)
            {
                if (rescure)
                {
                    if (t.GetComponent<CodeLinkerObject>() != null)
                    {
                        rescure = false;
                    }
                }
            }

            if (rescure)
            {
                for (int i = 0; i < t.childCount; i++)
                {
                    var child = t.GetChild(i);
                    FindMark(false, child, dic, path);
                }
            }

        }

        private static string ToProertyFormat(string name)
        {
            return name.Substring(0,1).ToUpper() + name.Substring(1);
        }

        private static string ToBackfeildFormat(string name)
        {
            return "_" + name.Substring(0,1).ToLower() + name.Substring(1);
        }

        public static String FindCodeFilePath(string codeFileName)
        {
            var searchStr = codeFileName + " t:script";
            var idList = AssetDatabase.FindAssets(searchStr);
            //Debug.Log(searchStr);
            foreach (var id in idList)
            {
                var path = AssetDatabase.GUIDToAssetPath(id);
                //Debug.Log(path);
                var fileName = Path.GetFileName(path);
                if (fileName == codeFileName + ".cs")
                {
                    return path;
                }
            }
            return null;
        }

        public static string ResolveCodeFilePath(string className)
        {
            var fileName = className + "+";
            var filePath = FindCodeFilePath(fileName);
            if (!string.IsNullOrEmpty(filePath))
            {
                return filePath;
            }
            else
            {
                var generateCodeDir = "Assets/Game/CodeLinkerGenerate";
                if (!Directory.Exists(generateCodeDir))
                {
                    Directory.CreateDirectory(generateCodeDir);
                }
                var newFilePath = generateCodeDir + "/" + fileName + ".cs";
                return newFilePath;
            }
        }

    }

}